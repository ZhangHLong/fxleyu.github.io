---
layout   : post
title    : "Java中的特殊引用（java.lang.ref）"
date     : 2016-12-23 12:45:00
author   : fxleyu
tags:
    - Java
---

# Java中的特殊引用（java.lang.ref）

### 引用

## 软件包`java.lang.ref`的描述
提供了引用对象类，支持在某种程度上与垃圾回收器之间的交互。程序可以使用一个引用对象来维持对另外某一对象的引用，所采用的方式是使后者仍然可以被回收器回收。程序还可以安排在回收器确定某一给定对象的可到达性已经更改之后的某个时间得到通知。

## 概述
**包规范**
引用对象 封装了对另一个对象的引用，这样就可以像其他任何对象一样检查和操作引用自身。有三种类型的引用对象，按从弱到强依次为：软 引用、弱 引用和虚 引用。正如下面定义的那样，每种类型对应于一个不同的可到达性级别。软引用适用于实现内存敏感的缓存，弱引用适用于实现无法防止其键（或值）被回收的规范化映射，而虚引用则适用于以某种比 Java 终结机制更灵活的方式调度 pre-mortem 清除操作。 
每种引用对象类型都是通过抽象的基本 Reference 类的一个子类实现的。其中一个子类的实例封装了对特定对象的引用，该对象名为指示对象。每个引用对象都提供了获取和清除该引用的方法。引用对象是不可变的，因此，除了清除操作之外，没有提供 set 操作。通过添加任何所需的字段和方法，程序可以为这些子类进一步创建子类，或者可以不加更改地使用这些子类。 

通知
在创建引用对象时，通过向引用队列注册 一个适当的引用对象，程序可以请求在对象可到达性更改时获得通知。在垃圾回收器确定引用的可到达性已经更改为对应于引用类型的值之后的某一时间，它会将引用添加到相关的队列中。此时，该引用被认为是已加入队列的。通过轮询或阻塞，直到获得了引用，程序才可以从队列中移除引用。引用队列是通过 ReferenceQueue 类实现的。 
已注册的引用对象及其队列之间的关系是单向的。也就是说，队列不会追踪那些向它注册的引用。如果一个已注册的引用本身变得不可到达，则永远不会将它加入到队列中。使用引用对象的程序的责任是，确保对象是可达到的，只要程序对其指示对象感兴趣。 

虽然某些程序会选择专门使用一个线程从一个或多个队列中移除引用对象并处理它们，但这是绝对没有必要的。一种通常很有用的策略是：在执行另一个相当频繁的操作期间检查引用队列。例如，使用弱引用来实现弱键的哈希表能在每次访问表时轮询其引用队列。这就是 WeakHashMap 类的工作方式。因为 ReferenceQueue.poll 方法仅仅检查内部数据结构，此检查只为哈希表访问方法增加了很小的系统开销。 

自动清除引用
在将软引用和弱引用添加到向其注册的队列（如果有）之前，回收器将自动清除这些引用。所以，软引用和弱引用不需要向队列注册即可使用，而虚引用则需要这样做。通过虚引用可到达的对象将仍然保持原状，直到清除所有这类引用或者它们本身变得不可到达。 
可到达性
从最强到最弱，不同的可到达性级别反映了对象的生命周期。在操作上，可将它们定义如下： 
如果某一线程可以不必遍历所有引用对象而直接到达一个对象，则该对象是强可到达 对象。新创建的对象对于创建它的线程而言是强可到达对象。 
如果一个对象不是强可到达对象，但通过遍历某一软引用可以到达它，则该对象是软可到达 对象。 
如果一个对象既不是强可到达对象，也不是软可到达对象，但通过遍历弱引用可以到达它，则该对象是弱可到达 对象。当清除对某一弱可到达对象的弱引用时，便可以终止此对象了。 
如果一个对象既不是强可到达对象，也不是软可到达对象或弱可到达对象，它已经终止，并且某个虚引用在引用它，则该对象是虚可到达 对象。 
最后，当不能以上述任何方法到达某一对象时，该对象是不可到达 对象，因此可以回收此对

## `WeakReference`（弱引用对象）
弱引用对象，它们并不禁止其指示对象变得可终结，并被终结，然后被回收。弱引用最常用于实现规范化的映射。 

假定垃圾回收器确定在某一时间点上某个对象是弱可到达对象。这时，它将自动清除针对此对象的所有弱引用，以及通过强引用链和软引用，可以从其到达该对象的针对任何其他弱可到达对象的所有弱引用。同时它将声明所有以前的弱可到达对象为可终结的。在同一时间或晚些时候，它将那些已经向引用队列注册的新清除的弱引用加入队列。 

## `SoftReference`（软引用对象）
软引用对象，在响应内存需要时，由垃圾回收器决定是否清除此对象。软引用对象最常用于实现内存敏感的缓存。 

假定垃圾回收器确定在某一时间点某个对象是软可到达对象。这时，它可以选择自动清除针对该对象的所有软引用，以及通过强引用链，从其可以到达该对象的针对任何其他软可到达对象的所有软引用。在同一时间或晚些时候，它会将那些已经向引用队列注册的新清除的软引用加入队列。 

软可到达对象的所有软引用都要保证在虚拟机抛出 OutOfMemoryError 之前已经被清除。否则，清除软引用的时间或者清除不同对象的一组此类引用的顺序将不受任何约束。然而，虚拟机实现不鼓励清除最近访问或使用过的软引用。 

此类的直接实例可用于实现简单缓存；该类或其派生的子类还可用于更大型的数据结构，以实现更复杂的缓存。只要软引用的指示对象是强可到达对象，即正在实际使用的对象，就不会清除软引用。例如，通过保持最近使用的项的强指示对象，并由垃圾回收器决定是否放弃剩余的项，复杂的缓存可以防止放弃最近使用的项。


## `PhantomReference`（）
虚引用对象，在回收器确定其指示对象可另外回收之后，被加入队列。虚引用最常见的用法是以某种可能比使用 Java 终结机制更灵活的方式来指派 pre-mortem 清除动作。 

如果垃圾回收器确定在某一特定时间点上虚引用的指示对象是虚可到达对象，那么在那时或者在以后的某一时间，它会将该引用加入队列。 

为了确保可回收的对象仍然保持原状，虚引用的指示对象不能被获取：虚引用的`get`方法总是返回`null`。 

与软引用和弱引用不同，虚引用在加入队列时并没有通过垃圾回收器自动清除。通过虚引用可到达的对象将仍然保持原状，直到所有这类引用都被清除，或者它们都变得不可到达。 

